[{"path":"/#iot4---20070","title":"Labs -- IoT4/20070 -> IoT4 - 20070","body":"This site hosts the labs for the IoT4 - 20070 class at Microchip MASTERS 2016. Use the links below see each lab.\n","preview":"<p>This site hosts the labs for the IoT4 - 20070 class at Microchip MASTERS 2016. Use the links below see each lab.</p>\n"},{"path":"/#labs","title":"Labs -- IoT4/20070 -> IoT4 - 20070 -> Labs","body":"[Lab 1](./lab1)\n[Lab 2](./lab2)\n[Lab 3](./lab3)\n","preview":"<p><a href=\"./lab1\">Lab 1</a></p>\n"},{"path":"/#optional-labs--guides","title":"Labs -- IoT4/20070 -> IoT4 - 20070 -> Optional Labs & Guides","body":"[Lab Setup Guide](./setup)\n<s>[Lab 4 - Murano](./lab4)</s>\n<s>[Lab 5 - HTTP Lab](./http)</s>\n<s>[Lab 6 - CoAP Lab](./coap)</s>\n","preview":"<p><a href=\"./setup\">Lab Setup Guide</a></p>\n"},{"path":"/coap/#lab-2---coap","title":"Lab 2 - CoAP -> Lab 2 - CoAP","body":"This is the CoAP lab. In this lab you will learn to understand the CoAP protocol at a high level for the purposes of debugging IoT devices during development. Most of this lab should be familiar to you; the majority of it parallels Lab 1 on HTTP.\n","preview":"<p>This is the CoAP lab. In this lab you will learn to understand the CoAP protocol at a high level for the purposes of debugging IoT devices during development. Most of this lab should be familiar to you; the majority of it parallels Lab 1 on HTTP.</p>\n"},{"path":"/coap/#part-1---understanding-the-basics-of-coap","title":"Lab 2 - CoAP -> Lab 2 - CoAP -> Part 1 - Understanding the basics of CoAP","body":"Note: The format of messages used in this lab is **not** the actual format of a CoAP message. CoAP is a binary protocol that is not easily human readable. Instead this lab uses a format of my own creation that I'm using purely for its ease of understanding. It's simply a JSON object where each member is one of the components of a CoAP message encoded in an human readable manner.\n","preview":"<p>Note: The format of messages used in this lab is <strong>not</strong> the actual format of a CoAP message. CoAP is a binary protocol that is not easily human readable. Instead this lab uses a format of my own creation that I&#39;m using purely for its ease of understanding. It&#39;s simply a JSON object where each member is one of the components of a CoAP message encoded in an human readable manner.</p>\n"},{"path":"/coap/#a-basic-request","title":"Lab 2 - CoAP -> Lab 2 - CoAP -> Part 1 - Understanding the basics of CoAP -> A Basic Request","body":"Copy and Paste the Following into the request box on [https://play-dev.exosite.io/coap](https://play-dev.exosite.io/coap):\n{\n    \"version\": 1,\n    \"type\": \"CON\",\n    \"code\": \"GET\",\n    \"mid\": 55,\n    \"token\": [45,203],\n    \"opts\": {\n        \"UriPath\": [\n            \"ts\"\n        ]\n    }\n}\nPress the \\[Send\\] button.\nWhat happened? Do you think it worked?\nCompare this to the HTTP requests you made in Lab 1, it may not look it at first glance, but this request was very similar to the initial request in Lab 1. In lab 1 you made a \"get\" request to \"/timestamp\", in this lab you made a \"get\" request to \"/ts\".\nChange the word `GET` to `POST` and press \\[Send\\] again.\nYou'll see that the response changed. Compare the two different responses, one indicates an error and one indicates a success.\nLook at the `code` member in the JSON object, see that it changed from \"Content\" to \"MethodNotAllowed\", this should seem very similar to you after the the HTTP lab. In the HTTP lab the response reason was \"OK\", in CoAP \"Content\" has the same meaning (in addition to combining a few other HTTP reasons). When we changed to a POST we, again, got a response saying \"Method Not Allowed\". CoAP was designed to be very similar to HTTP so that developers already familiar with HTTP would be able to understand CoAP very quickly.\n","preview":"<p>Copy and Paste the Following into the request box on <a href=\"https://play-dev.exosite.io/coap\">https://play-dev.exosite.io/coap</a>:</p>\n"},{"path":"/coap/#understanding-options","title":"Lab 2 - CoAP -> Lab 2 - CoAP -> Part 1 - Understanding the basics of CoAP -> Understanding Options","body":"Options in CoAP are very similar to headers in HTTP, let's explore them.\nSend the original request again, copy and paste the following into [https://play-dev.exosite.io/coap](https://play-dev.exosite.io/coap):\n{\n    \"version\": 1,\n    \"type\": \"CON\",\n    \"code\": \"GET\",\n    \"mid\": 55,\n    \"token\": [45,203],\n    \"opts\": {\n        \"UriPath\": [\n            \"ts\"\n        ]\n    }\n}\nThe one option that we are sending is a URI-Path option, in this case we're sending a URI with a single path component, that is to say the URI path is \"/ts\".\nPress the \\[Send\\] button.\nCompare the response of that request to the response of the following request:\n{\n    \"version\": 1,\n    \"type\": \"CON\",\n    \"code\": \"GET\",\n    \"mid\": 55,\n    \"token\": [45,203],\n    \"opts\": {\n        \"UriPath\": [\n            \"ts\"\n        ],\n        \"Accept\": 42\n    }\n}\nDo you notice a difference in the response?\nThis request adds an `Accept` option which specifies the format of the response that the requester would like to receive. There's no default value for Accept so the server is free to use any default format it wants. In the case of the second request we're setting a value of 42 which [is defined as](https://www.iana.org/assignments/core-parameters/core-parameters.xhtml#content-formats) \"application/octet-stream\", which just means \"arbitrary binary data\", and which we are using as a method to send a 32-bit timestamp in a raw format.\n","preview":"<p>Options in CoAP are very similar to headers in HTTP, let&#39;s explore them.</p>\n"},{"path":"/coap/#understanding-codes","title":"Lab 2 - CoAP -> Lab 2 - CoAP -> Part 1 - Understanding the basics of CoAP -> Understanding Codes","body":"Again, much like a request method, coap uses a 'code' to define what the message type is.\nSend the original request again, copy and paste the following into [https://play-dev.exosite.io/coap](https://play-dev.exosite.io/coap):\n{\n    \"version\": 1,\n    \"type\": \"CON\",\n    \"code\": \"GET\",\n    \"mid\": 55,\n    \"token\": [45,203],\n    \"opts\": {\n        \"UriPath\": [\n            \"ts\"\n        ]\n    }\n}\nSee that in this request we have a 'code' of \"GET\" which indicates that this is the same type of request that would be used for an HTTP request with a method of \"GET\".\nPress the \\[Send\\] button.\nCompare that **request** to the following request (the response is not as important in this case):\n   {\n       \"version\": 1,\n       \"type\": \"CON\",\n       \"code\": \"POST\",\n       \"mid\": 56,\n       \"token\": [45,37],\n       \"opts\": {\n           \"UriPath\": [\n               \"rpc\"\n           ]\n       },\n       \"payload\": \"{}\"\n   }\nAgain, just like in HTTP we change from a \"GET\" to a \"POST\" and add a payload (\"body\" in HTTP terms.)\nYou should get an error response to that request, that is expected. We'll use POST requests that actually get a success response more in the RPC section.\n","preview":"<p>Again, much like a request method, coap uses a &#39;code&#39; to define what the message type is.</p>\n"},{"path":"/coap/#an-aside","title":"Lab 2 - CoAP -> Lab 2 - CoAP -> An Aside","body":"You don't need to understand this part it's only used to generate a token that will be used later in this lab.\nYou may have already done this in Lab 1, but the keys that this script generates are automatically deleted periodically so your old key may no longer work.\nPaste the following into the `script` box on [https://play-dev.exosite.io/script](https://play-dev.exosite.io/script).\nlocal exosite = require('https://lualib.webscript.io/exosite-lua-js.lua')\nlocal json = require(\"https://lualib.webscript.io/dkjson.lua\")\n\n-- create client through CIK Fountain\nlocal status, cik = exosite.get_temporary_cik()\nprint(\"USE THIS CIK: \" .. cik)\nprint(status, cik)\n\n-- create dataport\nlocal exo = exosite.rpc:new{cik = cik}\nlocal status, response = exo:create{\n  \"dataport\",\n  {\n    format = \"float\",\n    name = \"Temperature\",\n    retention = {\n      count = \"infinity\",\n      duration = \"infinity\"\n    }\n  }\n}\nprint(status, json.encode(response))\nlocal rid = response.result\n\n-- map alias to dataport\nlocal status, response = exo:map{\"alias\", rid, \"temp\"}\nprint(status, json.encode(response))\n\n-- write a value to dataport\nlocal status, response = exo:write{ {alias=\"temp\"}, 23.3}\nprint(status, json.encode(response))\n\n-- read value that was just written, for debugging purposes\nlocal status, response = exo:read{ {alias=\"temp\"}, {}}\nprint(status, json.encode(response))\n\n-- get info for client, for debugging purposes\nlocal status, response = exo:info{ {alias=\"\"}, {}}\nprint(status, json.encode(response))\nPress the \\[Run\\] button.\nFind the CIK at the beginning of the log, it will be printed after \"USE THIS CIK:\". Copy it and **save this key** in a local document on your computer, this is an auth token to be used with the Exosite platform which you will be using at various times later in this lab.\nIf you're curious, this is a lua script that runs within your browser, calling the Exosite [RPC API](http://docs.exosite.com/rpc) through a lua library included in the first line. It first creates a new client using the \"CIK Fountain\", which is a tool to create a client that will get automatically deleted in 30 minutes, and then creates some resources within that client that you will interact with later in this lab.\n","preview":"<p>You don&#39;t need to understand this part it&#39;s only used to generate a token that will be used later in this lab.</p>\n"},{"path":"/coap/#rest","title":"Lab 2 - CoAP -> Lab 2 - CoAP -> Request Patterns with HTTP -> Rest","body":"REST, or Representational State Transfer, is one of the simplest structured patterns that you can use on top of CoAP. This example shows making a REST-like request to Exosite's device API.\nCopy and Paste the Following into the request box on [https://play-dev.exosite.io/coap](https://play-dev.exosite.io/coap):\n{\n  \"version\": 1,\n  \"type\": \"CON\",\n  \"code\": \"GET\",\n  \"mid\": 9,\n  \"token\": [76,2203],\n  \"opts\": {\n    \"UriPath\": [\n      \"1a\",\n      \"temp\"\n    ],\n    \"UriQuery\": [\n      \"<CIK>\"\n    ],\n    \"Observe\":0\n  }\n}\nNote:  Again, there are two blank lines after the text in the above example are important, make sure they are included after you paste into the `http terminal` page. And make sure to replace `<CIK>` with the CIK you generated earlier.\nPress the \\[Send\\] button.\n","preview":"<p>REST, or Representational State Transfer, is one of the simplest structured patterns that you can use on top of CoAP. This example shows making a REST-like request to Exosite&#39;s device API.</p>\n"},{"path":"/coap/#rpc","title":"Lab 2 - CoAP -> Lab 2 - CoAP -> Request Patterns with HTTP -> RPC","body":"RPC, or Remote Procedure Call, is another communication pattern that can be built on top of HTTP\nCopy and Paste the Following into the request box on [https://play-dev.exosite.io/coap](https://play-dev.exosite.io/coap):\n{\n    \"version\": 1,\n    \"type\": \"CON\",\n    \"code\": \"POST\",\n    \"mid\": 163,\n    \"token\": [9],\n    \"opts\": {\n        \"UriPath\": [\n            \"rpc\"\n        ],\n        \"ContentFormat\": 60,\n        \"Accept\": 60\n    },\n    \"payload\": {\n       \"auth\": {\n           \"cik\": \"<CIK>\"\n       },\n       \"calls\": [\n           {\n               \"procedure\": \"read\",\n               \"arguments\": [\n                   {\"alias\": \"temp\"},\n                   {}\n               ],\n               \"id\": 1\n           }\n       ]\n   }\n}\nNote:  There is a bit of extra magic going on here. This request has it's Content-Format set to '60' this is the Content-Format for [CBOR](http://cbor.io), a binary encoding format for JSON-like data structures. The CoAP Terminal will automatically encode an object-type payload into cbor when the Content-Format is set to application/cbor (60). It will also decode anything that looks like cbor into an object to be shown as JSON in the friendly format.\nPress the \\[Send\\] button.\n","preview":"<p>RPC, or Remote Procedure Call, is another communication pattern that can be built on top of HTTP</p>\n"},{"path":"/http/#lab-1---http","title":"Lab 1 - HTTP -> Lab 1 - HTTP","body":"This is the HTTP lab. In this lab you will learn to understand the basics of HTTP, the Hypertext Transport Protocol, at a high level for the purposes of debugging IoT devices during development.\n","preview":"<p>This is the HTTP lab. In this lab you will learn to understand the basics of HTTP, the Hypertext Transport Protocol, at a high level for the purposes of debugging IoT devices during development.</p>\n"},{"path":"/http/#a-basic-request","title":"Lab 1 - HTTP -> Lab 1 - HTTP -> Part 1 - Understanding the basics of HTTP -> A Basic Request","body":"Copy and Paste the Following into the request box on [https://play-dev.exosite.io/http](https://play-dev.exosite.io/http):\nGET /timestamp HTTP/1.1\nHost: m2.exosite.com\n\n​\nNote: There are two blank lines after the text in the above example are important, make sure they are included after you paste into the `http terminal` page.\nPress the \\[Send\\] button.\nWhat happened? Do you think it worked?\nChange the word `GET` to `POST` and press \\[Send\\] again.\nYou'll see that the response changed. Compare the two different responses, one indicates an error and one indicates a success. Can you tell which is which?\nLook at the first line in the response, this is the status line, the number after `HTTP/1.1` is the status code (either an error code or some form of success code), which is then followed by the reason phrase. You'll see that the success response has a status code of \"200\" and a reason phrase of \"OK\". These two tell you the same information in *most* cases, but both are still required.\n","preview":"<p>Copy and Paste the Following into the request box on <a href=\"https://play-dev.exosite.io/http\">https://play-dev.exosite.io/http</a>:</p>\n"},{"path":"/http/#understanding-headers","title":"Lab 1 - HTTP -> Lab 1 - HTTP -> Part 1 - Understanding the basics of HTTP -> Understanding Headers","body":"Send the original request again, copy and paste the following into [https://play-dev.exosite.io/http](https://play-dev.exosite.io/http) :\nGET /timestamp HTTP/1.1\nHost: m2.exosite.com\n\n​\nPress the \\[Send\\] button.\nCompare the response of that request to the response of the following request:\nGET /timestamp HTTP/1.1\nHost: m2.exosite.com\nNot-A-Real-Header: kill-all-humans\n\n​\nDo you notice a difference?\nThere should be no difference (other than the timestamp itself and the date shown in line 2). The difference between the first and second requests was the addition of a new header, the \"Not-A-Real-Header\" header. There was no change in how the server responded because the server doesn't know of any header called \"Not-A-Real-Header\" so it is allowed to ignore it.\n","preview":"<p>Send the original request again, copy and paste the following into <a href=\"https://play-dev.exosite.io/http\">https://play-dev.exosite.io/http</a> :</p>\n"},{"path":"/http/#understanding-methods","title":"Lab 1 - HTTP -> Lab 1 - HTTP -> Part 1 - Understanding the basics of HTTP -> Understanding Methods","body":"Send the original request again, copy and paste the Following into [https://play-dev.exosite.io/http](https://play-dev.exosite.io/http) :\nGET /timestamp HTTP/1.1\nHost: m2.exosite.com\n\n​\nPress the \\[Send\\] button.\nCompare the response of that request to the response of the following request:\nPOST /timestamp HTTP/1.1\nHost: m2.exosite.com\n\n​\nDo you notice a difference?\nThe second request causes an error to be returned. In this case it's a `406 Method Not Allowed` because we changed the method from `GET` to `POST` and the timestamp url does not support having data `POST`ed to it. The method, sometimes also called the \"verb\", states what kind of request is being sent. The most common are `GET` and `POST`, but there's also `PUT`, `DELETE`, `OPTIONS`, `HEAD`, and more. Some of these will be further explained later in the lab.\n","preview":"<p>Send the original request again, copy and paste the Following into <a href=\"https://play-dev.exosite.io/http\">https://play-dev.exosite.io/http</a> :</p>\n"},{"path":"/http/#understanding-message-bodies","title":"Lab 1 - HTTP -> Lab 1 - HTTP -> Part 1 - Understanding the basics of HTTP -> Understanding Message Bodies","body":"Send the original request again, copy and paste the Following into [https://play-dev.exosite.io/http](https://play-dev.exosite.io/http) :\nGET /timestamp HTTP/1.1\nHost: m2.exosite.com\n\n​\nPress the \\[Send\\] button.\nCompare that **request** to the following request (the response is not interesting in this case):\nPOST /api:v1/rpc/process HTTP/1.1\nHost: m2.exosite.com\nContent-Length: 2\n\n{}\nWhat differences do you see?\nUntil now you've had to make sure that all your requests end with two blank lines, however this request ends with no blank lines. Ending with two blank lines is a special case of an HTTP message where the message contains no body, the two blank lines actually indicate the division between the end of the headers and the beginning of the body. Because HTTP runs over TCP, a stream protocol, it's important to know where one request ends and another begin. This is the purpose of the `Content-Length` header, it tells the receiver of the message how many octets (8-bit bytes) of body it should expect to receive.\n","preview":"<p>Send the original request again, copy and paste the Following into <a href=\"https://play-dev.exosite.io/http\">https://play-dev.exosite.io/http</a> :</p>\n"},{"path":"/http/#an-aside","title":"Lab 1 - HTTP -> Lab 1 - HTTP -> An Aside","body":"You don't need to fully understand what is happening in this section it's only used to generate a token that you will use later in this lab.\nPaste the following into the `script` box on [https://play-dev.exosite.io/script](https://play-dev.exosite.io/script).\nlocal exosite = require('https://lualib.webscript.io/exosite-lua-js.lua')\nlocal json = require(\"https://lualib.webscript.io/dkjson.lua\")\n\n-- create client through CIK Fountain\nlocal status, cik = exosite.get_temporary_cik()\nprint(\"USE THIS CIK: \" .. cik)\nprint(status, cik)\n\n-- create dataport\nlocal exo = exosite.rpc:new{cik = cik}\nlocal status, response = exo:create{\n  \"dataport\",\n  {\n    format = \"float\",\n    name = \"Temperature\",\n    retention = {\n      count = \"infinity\",\n      duration = \"infinity\"\n    }\n  }\n}\nprint(status, json.encode(response))\nlocal rid = response.result\n\n-- map alias to dataport\nlocal status, response = exo:map{\"alias\", rid, \"temp\"}\nprint(status, json.encode(response))\n\n-- write a value to dataport\nlocal status, response = exo:write{ {alias=\"temp\"}, 23.3}\nprint(status, json.encode(response))\n\n-- read value that was just written, for debugging purposes\nlocal status, response = exo:read{ {alias=\"temp\"}, {}}\nprint(status, json.encode(response))\n\n-- get info for client, for debugging purposes\nlocal status, response = exo:info{ {alias=\"\"}, {}}\nprint(status, json.encode(response))\nPress the \\[Run\\] button.\nNote: This will lock-up your browser tab for a few seconds while it does it's work.\nFind the CIK at the beginning of the log, it will be printed after \"USE THIS CIK:\". Copy it and **save this key** in a document on your computer, this is an auth token to be used with the Exosite platform which you will be using at various times later in this lab.\nIf you're curious, this is a lua script that runs within your browser, calling the Exosite [RPC API](http://docs.exosite.com/rpc) through a lua library included in the first line. It first creates a new client using the \"CIK Fountain\", which is a tool to create a client that will get automatically deleted in 30 minutes, and then creates some resources within that client that you will interact with later in this lab.\n","preview":"<p>You don&#39;t need to fully understand what is happening in this section it&#39;s only used to generate a token that you will use later in this lab.</p>\n"},{"path":"/http/#rest","title":"Lab 1 - HTTP -> Lab 1 - HTTP -> Request Patterns with HTTP -> REST","body":"REST, Representational State Transfer, is the most common form of communication pattern that is being built on top of HTTP currently. The following performs a rest-like request to the Exosite platform.\nCopy and Paste the Following into the request box on [https://play-dev.exosite.io/http](https://play-dev.exosite.io/http):\nGET /onep:v1/stack/alias?temp HTTP/1.1\nHost: m2.exosite.com\nX-Exosite-CIK: <CIK>\nAccept: application/x-www-form-urlencoded; charset=utf-8\n\n​\nNote:  Again, there are two blank lines after the text in the above example are important, make sure they are included after you paste into the `http terminal` page. Also, you'll need to replace the text `<CIK>` with the CIK (auth token) you generate in the previous section.\nPress the \\[Send\\] button.\nYou should have received a response that indicated that the 'temp' dataport had a value of '23.3'.\nTAKE IT FURTHER: The request you just made was a 'read' request the the Exosite device API, you can find the documentation for that call here, [http://docs.exosite.com/http/#read](http://docs.exosite.com/http/#read). Now, try and take what you've learned to make a write request, see the documentation for that call here, [http://docs.exosite.com/http/#write](http://docs.exosite.com/http/#write)\n","preview":"<p>REST, Representational State Transfer, is the most common form of communication pattern that is being built on top of HTTP currently. The following performs a rest-like request to the Exosite platform.</p>\n"},{"path":"/http/#rpc","title":"Lab 1 - HTTP -> Lab 1 - HTTP -> Request Patterns with HTTP -> RPC","body":"RPC, or Remote Procedure Call, is another communication pattern that can be built on top of HTTP. The following \nCopy and Paste the Following into the request box on [https://play-dev.exosite.io/http](https://play-dev.exosite.io/http):\nPOST /api:v1/rpc/process HTTP/1.1\nHost: m2.exosite.com\nContent-Length: 2\n\n{}\nPress the \\[Send\\] button.\nCompare the response of that request to the response of the following request:\nPOST /api:v1/rpc/process HTTP/1.1\nHost: m2.exosite.com\nContent-Length: 128\n\n{\n   \"auth\": \"<CIK>\",\n   \"calls\": [{\n       \"method\": \"not-a-real-method\",\n       \"arguments\": {}\n       \"id\": 56\n   }]\n}\nYou'll see that even though we tried to use a method that does not exist, `not-a-real-method`, we got an HTTP response code of 200 indicating success. This is because RPC does not use the HTTP status code to indicate the success or failure of the calls themselvce, but only if indicate if the server was able to process the format of the request. Errors within each call are returned via the 'status' and 'error' members of the call response.\nRPC has the benefit of being able to carry more than one 'call' in a single request. For example we can fetch the full info about a dataport in the same call the we read from it:\nPOST /api:v1/rpc/process HTTP/1.1\nHost: m2.exosite.com\nContent-Length: 2\n\n{\n  \"auth\": \"<CIK>\",\n  \"calls\": [{\n      \"method\": \"read\",\n      \"arguments\": {\n          {\"alias\": \"temp\"},\n          {}\n      },\n      \"id\": 56\n  },{\n      \"method\": \"info\",\n      \"arguments\": {\n          {\"alias\": \"temp\"},\n          {}\n      },\n      \"id\": \"something-else\"\n  }]\n\n}\n","preview":"<p>RPC, or Remote Procedure Call, is another communication pattern that can be built on top of HTTP. The following </p>\n"},{"path":"/lab1/#lab-1---getting-started-with-the-exositeready-sdk","title":"Lab 1 - Getting Started with the ExositeReady SDK -> Lab 1 - Getting Started with the ExositeReady SDK","body":"The ExositeReady SDK is a software framework provided by Exosite to ease development of production-quality embedded device firmware for IoT products. It's open source software, provided under the Apache-2.0 license, that means that you're free to do whatever you'd like with it as long as you share any changes to the SDK itself while being able to keep the rest of your application's code private if that's what you'd like.\nIn this lab you'll go through getting the PIC32MZ Embedded Connectivity Starter Kit flashed with the demo firmware provided alongside the ER SKD. You'll learn the basics of what is required to get IoT devices connected to the Exosite platform and see real-time data from your devices streaming to your web browser.\n","preview":"<p>The ExositeReady SDK is a software framework provided by Exosite to ease development of production-quality embedded device firmware for IoT products. It&#39;s open source software, provided under the Apache-2.0 license, that means that you&#39;re free to do whatever you&#39;d like with it as long as you share any changes to the SDK itself while being able to keep the rest of your application&#39;s code private if that&#39;s what you&#39;d like.</p>\n"},{"path":"/lab1/#requirements","title":"Lab 1 - Getting Started with the ExositeReady SDK -> Lab 1 - Getting Started with the ExositeReady SDK -> Requirements","body":"PIC32MZ Embedded Connectivity Starter Kit\nAn Internet Connection\nA Computer with MPLAB IDE, including:\nMPLABX IDE v 3.30\nHarmony v1.08\nXC32 v1.40b\nThe ExositeReady SDK, plus\nThe PIC32MZECSK port & example application\nIf you don't have any of the above software installed, see the [Lab Setup Guide](../setup) before proceeding with this Lab. MASTERS attendees that have access to the in-class lab computers should have everything setup already.\n","preview":"<p>PIC32MZ Embedded Connectivity Starter Kit</p>\n"},{"path":"/lab1/#lets-go","title":"Lab 1 - Getting Started with the ExositeReady SDK -> Let's Go","body":"First you'll want to open MPLAB X.\n![MPLABX IDE Screenshot](../images/mplabx.png)\nAnd open the `er_vfp_microchip_harmony` project, which can be found in the \"C:\\microchip\\harmony\\v1_08\\apps\\er_vfp_microchip_harmony\\firmware\" folder.\n![Open Example Project](../images/open_example_project.png)\nYou can now explore the source of this project if you'd like.\n![Example Project Fresh](../images/example_project_fresh.png)\n","preview":"<p>First you&#39;ll want to open MPLAB X.</p>\n"},{"path":"/lab1/#running-the-example","title":"Lab 1 - Getting Started with the ExositeReady SDK -> Let's Go -> Running the Example","body":"Before we dig into what the code is doing, let's build, flash, and run the provided example.\nConnect the Starter Kit board to you computer using both mini USB connectors; one is for the onboard debugger and the other is for access to the serial terminal.\nIf you have more than one project open in MPLAB, make sure that the `er_vfp_microchip_harmony` project is set as the main project, it's name should appear in the window's title bar, you can do this simply clicking on the project in the 'Projects' tab in the left-side bar. Then click the \"Make and Program Device Main Project\" button to build the firmware image and flash it to the board.\n![Make and Program Device Main Project Button](../images/make_and_program_device_main_project_button.png)\nYou may be prompted to select a different device, this will happen if the starter kit you're using isn't the last one used with this project. MPLAB should offer to switch to the kit that is currently connected to your computer; just click \"OK\". If you're shown a list of tools, there should only be one valid option. Choose the item listed under \"Starter Kits (PKOB)\".\n![Tool List](../images/tool_list.png)\nIt will take several minutes to compile and flash the board.\nOnce this is complete, the board will boot the demo application, connect to Exosite's servers, and begin reading & writing data. Once this happens you should see the three LEDs, red, yellow, and green, along the 40-pin header turn on.\nTo follow the progress of the application booting and connecting, or to troubleshoot any issues, you can use a serial terminal application to view the application's debug log. Open the serial terminal application on the computer and connect to the virtual serial port provided by the device, it should be the only one available on your computer. If you don't see make sure you have a miniUSB cable connecting the port under the Ethernet port.\n<!-- NTS: Expand the above section after figuring out what application they will have on these machines. -->\n\n","preview":"<p>Before we dig into what the code is doing, let&#39;s build, flash, and run the provided example.</p>\n"},{"path":"/lab2/#lab-2---exploring-the-source","title":"Lab 2 - Exploring the Source -> Lab 2 - Exploring the Source","body":"You've now had some experience using the ExositeReady SDK on the Embedded Connectivity Starter Kit and have gotten it to connect to the Exosite platform. Next, in this lab, you'll explore the code more and make some subtle tweaks to how the example reports data to the platform. This is intended to increase your familiarity with where the key pieces of functionality are handled in the application.\n","preview":"<p>You&#39;ve now had some experience using the ExositeReady SDK on the Embedded Connectivity Starter Kit and have gotten it to connect to the Exosite platform. Next, in this lab, you&#39;ll explore the code more and make some subtle tweaks to how the example reports data to the platform. This is intended to increase your familiarity with where the key pieces of functionality are handled in the application.</p>\n"},{"path":"/lab2/#requirements","title":"Lab 2 - Exploring the Source -> Lab 2 - Exploring the Source -> Requirements","body":"PIC32MZ Embedded Connectivity Starter Kit\nAn Internet Connection\nA Computer with MPLAB IDE, including:\nMPLABX IDE v 3.30\nHarmony v1.08\nXC32 v1.40b\nThe ExositeReady SDK, plus\nThe PIC32MZECSK port & example application\nThe requirements here are the same as the first lab. If you have not completed that lab yet, it's **highly** recommend you do so before starting this lab.\n","preview":"<p>PIC32MZ Embedded Connectivity Starter Kit</p>\n"},{"path":"/lab2/#exploring-the-code","title":"Lab 2 - Exploring the Source -> Exploring the Code","body":"We'll start of in the source for the main application code which you can find in `Source File -> app -> app.c`. In this file you'll find the main `APP_TASKS` function that should be familiar to you if you've ever written firmware using Microchip's Harmony libraries before.\n![Example Project Fresh](../images/example_project_fresh.png)\nIf you're not familiar with this application structure, you'll see that the application is structured as a state machine where the APP_TASKS function returns when it is done with it's current task, keeping track of the application's state in the appData global variable structure. The main body of the function takes the form of a single switch statement with each case being an individual state of the state machine.\nTry to follow the state through the application and understand the basic progression of the state machine.\n![App Main State Machine](../images/app_main_state_machine.png)\nIn this application the app will spend most of it's time in the `APP_APPLICATION` state. This is where all the interaction with the Exosite platform is controlled.\n![App Application State](../images/app_application_state.png)\nHere you can see that we're reading a couple of dataports, \"leds\" and \"count\". \"leds\" is pretty obvious, it' reads a value that sets which LEDs are on and which are off. \"count\" is simply a numeric value that we can change with SW1 and SW2, this initial read is just to sync the previous value from the cloud.\n\"count\" is also written back up to the cloud anytime the value changes in the next section.\nThe `exosite_read` call in this state for \"leds\" should actually never be called, see if you can figure out why.\nSee that we first call `exosite_subscribe` and do an initial call to `exosite_read` before the main application state is entered. Also, note that we're doing both a read and a subscribe, a subscribe call only will receive changes that are made in the future, it will not receive a value for the current state.\n![App Create Subscriptions State](../images/app_create_subscriptions_state.png)\nIf you look at the `on_read` call as well as the code to write to the \"count\" dataport you'll see that the numeric values of the count and leds state are converted to ASCII text. All requests that are sent to the API this demo uses require the messages to be UTF-8 encoded (of which ASCII is a subset, if you didn't know) so this library requires you to format all your requests before handing them off. It's done this way to simplify the communication protocols, using only standard web protocols and formats.\nYou may also note that we're only using a single dataport to encode the state of all of the LEDs. This way of encoding multiple independent inputs and outputs is done to reduce the resources required to communicate the data to the platform. You could split each LED and button into their own dataport, but that would require writing to multiple dataports and, more importantly, opening several connections to the platform to wait on changes to each dataport. This is partially a limitation of the API used by this library, Exosite has new device-side APIs that will get rid of this limitation.\n![on_read Function](../images/on_read_function.png)\n","preview":"<p>We&#39;ll start of in the source for the main application code which you can find in <code>Source File -&gt; app -&gt; app.c</code>. In this file you&#39;ll find the main <code>APP_TASKS</code> function that should be familiar to you if you&#39;ve ever written firmware using Microchip&#39;s Harmony libraries before.</p>\n"},{"path":"/lab2/#making-some-tweaks","title":"Lab 2 - Exploring the Source -> Making some Tweaks","body":"The 'Product' model that is being used for these demos has a few more dataports that aren't being used in the example application, let's make some really simple modifications to use them. We want to change to to reading the `party_leds` dataport to set the state of the LEDs. We'll also want to make the buttons change the value in the `party_on_off` dataport.\nThe `party_leds` dataport uses the same format as the `leds` dataport. The `party_on_off` the same format as `count`, where \"0\" mean \"off\" and anything else means \"on\".\nBefore continuing to read the lab, try to see if you can make the changes to use these dataports instead of the ones included in the original example. If you're having trouble the following section will walk you through the steps needed.\n","preview":"<p>The &#39;Product&#39; model that is being used for these demos has a few more dataports that aren&#39;t being used in the example application, let&#39;s make some really simple modifications to use them. We want to change to to reading the <code>party_leds</code> dataport to set the state of the LEDs. We&#39;ll also want to make the buttons change the value in the <code>party_on_off</code> dataport.</p>\n"},{"path":"/lab2/#the-walkthrough","title":"Lab 2 - Exploring the Source -> Making some Tweaks -> The Walkthrough","body":"Both of these changes should be fairly trivial, but here is a step-by-step walkthrough of the changes in case you missed anything.\nFirst, for the changes to the LEDs you simply need to change any instance of the string \"leds\" to \"party_leds\". Make sure to change them in both the \"APP_APPLICATION\" and \"APP_CREATE_SUBSCRIPTIONS\" states of the main `APP_Tasks` function as well as in the `on_read` and `on_change` functions.\nSecond, to change the handling of the button, we'll leave most of the code that handles that alone again and just change the dataport to which it's written. Again, you'll need to change any instance of the string \"count\" to \"party_on_off\". You'll need to make this change in the \"APP_APPLICATION\" state of the main `APP_Tasks` function and the `on_read` function.\nNow compile and flash you changes. Once this has finished and your board has rebooted and re-connected you should be able to press SW1 to turn \"party mode\" on and see the LEDs flash randomly, changing approximately once every second.\n","preview":"<p>Both of these changes should be fairly trivial, but here is a step-by-step walkthrough of the changes in case you missed anything.</p>\n"},{"path":"/lab2/#bonus-points","title":"Lab 2 - Exploring the Source -> Making some Tweaks -> Bonus Points","body":"TBC\n","preview":"<p>TBC</p>\n"},{"path":"/lab3/#lab-3---adding-a-real-sensor","title":"Lab 3 - Adding a Real Sensor -> Lab 3 - Adding a Real Sensor","body":"Now that you've gotten familiar with where some of the pieces of applications built on the ExositeReady SDK are found, we're going to go through adding some new hardware to show you how to integrate other sensors or devices into an ExositeReady SDK application.\n","preview":"<p>Now that you&#39;ve gotten familiar with where some of the pieces of applications built on the ExositeReady SDK are found, we&#39;re going to go through adding some new hardware to show you how to integrate other sensors or devices into an ExositeReady SDK application.</p>\n"},{"path":"/lab3/#requirements","title":"Lab 3 - Adding a Real Sensor -> Lab 3 - Adding a Real Sensor -> Requirements","body":"PIC32MZ Embedded Connectivity Starter Kit\nWeather Click Board\nOLED Click Board\nAdapter Board\nAn Internet Connection\nA Computer with MPLAB IDE, including:\nMPLABX IDE v 3.30\nHarmony v1.08\nXC32 v1.40b\nThe ExositeReady SDK, plus\nThe PIC32MZECSK port & example application\nThe software requirements for this lab are the same as the first lab. If you have not completed that lab yet, it's **highly** recommend you do so before starting this lab.\n","preview":"<p>PIC32MZ Embedded Connectivity Starter Kit</p>\n"},{"path":"/lab3/#the-plan","title":"Lab 3 - Adding a Real Sensor -> Lab 3 - Adding a Real Sensor -> The Plan","body":"You've been provided with a couple of mikrobus click boards, one containing a 'weather' (temperature, pressure, and humidity) and one containing an OLED display. In this lab we're going to add support for reading the temperature sensor and reporting the values from it in real time out to the Exosite platform for display in your web browser.\nTo change this we'll need to remove all the code that handles the LEDs and buttons and replace it with code that handles talking I2C to the [BME280](https://www.bosch-sensortec.com/bst/products/all_products/bme280) temperature/pressure/humidity sensor and SPI to the controller for the OLED display.\nNote: If you get stuck at any point during this tutorial, you can run `git diff origin/click_demo {filename}` to compare your current file to what we're going for. For example to compare your app.c file to my end result, run `git diff origin/click_shield_demo firmware/src/app.c` from the `er_vfp_microchip_harmony` folder. The output of the full project diff is available [here](../files/lab3_changes.patch) if you don't know how to use git.\n","preview":"<p>You&#39;ve been provided with a couple of mikrobus click boards, one containing a &#39;weather&#39; (temperature, pressure, and humidity) and one containing an OLED display. In this lab we&#39;re going to add support for reading the temperature sensor and reporting the values from it in real time out to the Exosite platform for display in your web browser.</p>\n"},{"path":"/lab3/#lets-go","title":"Lab 3 - Adding a Real Sensor -> Lab 3 - Adding a Real Sensor -> Let's Go","body":"The biggest, and easiest, changes will be the removal of the file containing the bulk of the code controlling the switches and the addition of the files containing the bulk of the code controlling the weather sensor and display, let's start with that.\nIf you haven't yet, download the [files.zip](../files/files.zip) file, then extract the files and copy the .c and .h files (one each for \"display_ctrl\" and \"sensor\") to the `er_vfp_microchip_harmony/firemware/src` directory.\nNext, in MPLAB, remove \"switch_control.c\" from the project (right-click menu). Then add both \"sensor.c\" and \"display_ctrl.c\" to the project, I like to put them in the \"app\" group, do this by right-clicking on \"app\" under \"Source Files\" and choosing \"Add Existing Item\".\n![Right Click Menu on App](../images/right_click_menu_on_app.png)\nYou'll also want to copy over the system config folder from the zip file, also into the `er_vfp_microchip_harmony/firemware/src` directory, these files change what tasks our RTOS is running. The changes made a fairly straightforward, but as configuring and RTOS is outside the scope of the class we'll just copy the files for the sake of time. Feel free to find the changes or read the diff linked above.\nNext we'll start modifying the app.c source itself. Near the top of the file, on line 112, we'll no longer need the global counter variable, you can remove it:\nint gCounter\nWhile we're here, lets add some `extern`s for a couple of functions the application will be using:\nextern int getTemperature(void);\nextern int getHumidity(void);\nNext, find the 'on_read' function, remove all the existing code from inside it, except the `SYS_CONSOLE_PRINT` call, which is still going to be useful for debugging and refill it with the following code:\nif (status == ERR_SUCCESS) {\n  if(!strcmp(\"display\", alias)) {\n    display_print_remote_msg(value);\n    appData.remote_msg_initialized = INITIALIZED;\n  }\n} else {\n  /* In case of error, the reading will be repeated */\n  appData.remote_msg_initialized = NOT_INITIALIZED;\n}\nDo the same thing in 'on_change':\nASSERT(!strcmp(\"display\", alias));\n\nif (status == ERR_SUCCESS) {\n  appData.remote_msg_initialized = INITIALIZED;\n  printf(\"Value changed on server \\\"%s\\\" to %s\\n\", alias, value);\n  display_print_remote_msg(value);\n}\nThe 'on_write' function will stay the same since it's only got a debug output message in it.\nNext, we'll move to the 'APP_Initialize' function where you'll replace\nappData.leds_initialized = NOT_INITIALIZED;\nappData.counter_initialized = NOT_INITIALIZED;\nwith \nappData.remote_msg_initialized = NOT_INITIALIZED;\nNow, getting to \"APP_Tasks\", where the largest number of changes need to be made, near the beginning of the function, change the `countDiff` variable to `sensor_val` (it should stay an `int`).\nNext, we want to create a new state that waits for the display to finish initializing itself. I've chosen to put this between the states \"APP_TCPIP_WAIT_FOR_IP\" and \"APP_ER_SDK_INIT\". Here is the new state as I've created it: \ncase APP_DISPLAY_INIT:\n  if(!is_display_ready())\n    break;\n\n  SYS_CONSOLE_MESSAGE(\" Display initialized\\r\\n\");\n\n  if (display_print_sn()!= ERR_SUCCESS) {\n    appData.state = APP_PLATFORM_ERROR;\n    break;\n  }\n\n  appData.state = APP_ER_SDK_INIT;\n  break;\nYou'll then also need to make sure to change the previous state's setting of the next state, if you put your state in the same location as I did that means changing `appData.state = APP_ER_SDK_INIT;` to:\nappData.state = APP_DISPLAY_INIT;\nIn the \"APP_CREATE_SUBSCRIPTIONS\" state we'll want to change the name of the dataport that we're subscribed to. Simply change the string `\"leds\"` to `\"display\"` in both the subscribe and read functions.\nIn the same piece of code, change `appData.leds_initialized = IN_PROGRESS;` to: `appData.remote_msg_initialized = IN_PROGRESS;`\nYou'll want it to look like:\nif(exosite_subscribe(exo, \"display\", 0, on_change) == ERR_SUCCESS) {\n  appData.remote_msg_initialized = IN_PROGRESS;\n  exosite_read(exo, \"display\", on_read);\n  appData.state = APP_APPLICATION;\n}\nIn the next state, \"APP_APPLICATION\", we'll do exactly the same things for the read calls. That should now look like:\nif (appData.remote_msg_initialized == NOT_INITIALIZED) {\n  appData.remote_msg_initialized = IN_PROGRESS;\n  exosite_read(exo, \"display\", on_read);\n}\nThe following couple blocks of code, the code that reads from and writes to the \"count\" dataport should simply be deleted.\nWe'll replace it with code to write to the \"temperature\" dataport:\nsensor_val = getTemperature();\nsprintf(str, \"%d.%01dC\", (sensor_val/100),(sensor_val%100)/10);\nSYS_CONSOLE_PRINT(\"Temperature: %s\\r\\n\", str);\nexosite_write(exo, \"temperature\", str, on_write);\nThat's finally everything for app.c.\nWe did change the names of some of the items that are defined in app.h. So open \"Header Files\" -> \"app\" -> \"app.h\".\nFirst we need to add a \"APP_DISPLAY_INIT\" state to the \"APP_STATES\" enum. Second, we need to update the \"APP_DATA\" struct. Currently the annonomus enum defines two fields of the struct, \"leds_initialized\" and \"counter_initialized\". Remove both of those and replace it with a single field named \"remote_msg_initialized\". You should now have: \nenum { NOT_INITIALIZED = 0, IN_PROGRESS, INITIALIZED } remote_msg_initialized;\nWe've now re-configured everything to use our new sensor, reading the temperature, and our new display, to display messages read from the platform. There is, however, one last change I've saved for last. Our device is still identifying itself as the same type of device we used in the first two labs, but we're now expecting an entirely different set dataports for reading from and writing to. I've created a second product for our new weather sensor device to use, it has a product ID of \"<TBD>\", you need to change this in app.c. Near the beginning of \"APP_Tasks\" there's two variables `vendor` and `model`, set both of these to \"<TBD>\". You should now have:\nchar *vendor = \"<TBD>\";\nchar *model = \"<TBD>\";\nNow, that's all! Make sure you've saved all the files.\nSince we changed some files outside MPLAB I'd suggest doing a clean build just to make sure all our changes are compiled in. Then program the new firmware to the device\n![Clean Build Button](../images/clean_build_button.png)\n","preview":"<p>The biggest, and easiest, changes will be the removal of the file containing the bulk of the code controlling the switches and the addition of the files containing the bulk of the code controlling the weather sensor and display, let&#39;s start with that.</p>\n"},{"path":"/lab3/#using-your-new-creation","title":"Lab 3 - Adding a Real Sensor -> Lab 3 - Adding a Real Sensor -> Using your New Creation","body":"I've created another web UI that is associated with this new product ID, you can now see your new creation through [https://weathersensor.apps.exosite.io](https://weathersensor.apps.exosite.io).\n","preview":"<p>I&#39;ve created another web UI that is associated with this new product ID, you can now see your new creation through <a href=\"https://weathersensor.apps.exosite.io\">https://weathersensor.apps.exosite.io</a>.</p>\n"},{"path":"/lab3/#humidity","title":"Lab 3 - Adding a Real Sensor -> Lab 3 - Adding a Real Sensor -> Bonus Points -> Humidity","body":"The libraries you included also have a `getHumidity()`function, see if you can figure out how to write this to the \"humidity\" dataport that is also part of the client model you're using. Use the code that writes the temperature as a template.\n","preview":"<p>The libraries you included also have a <code>getHumidity()</code>function, see if you can figure out how to write this to the &quot;humidity&quot; dataport that is also part of the client model you&#39;re using. Use the code that writes the temperature as a template.</p>\n"},{"path":"/plan/#yaks","title":"plan -> Goal: Write Labs -> Yaks","body":"Make public UI for devices.\nWrite simple \"starting-point\" application using LEDs and buttons.\n","preview":"<p>Make public UI for devices.</p>\n"},{"path":"/setup/#prerequisites","title":"Lab Setup Guide -> Prerequisites","body":"Make sure you have the following software from Microchip already installed:\nMPLAB X (tested with v3.30)\nHarmony (tested with v1.08)\nXC32 (tested with v1.40)\nYou will also need to have [Git SCM](https://git-scm.com/) (or any git access tool, but you're on your own if you use something else).\n","preview":"<p>Make sure you have the following software from Microchip already installed:</p>\n"}]