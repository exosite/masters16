[{"path":"/#iot4---20070","title":"Jekyll Docs Template -> IoT4 - 20070","body":"This site hosts the labs for the IoT4 - 20070 class at Microchip MASTERS 2016. Use the links on the left to see each lab.\n","preview":"<p>This site hosts the labs for the IoT4 - 20070 class at Microchip MASTERS 2016. Use the links on the left to see each lab.</p>\n"},{"path":"/#labs","title":"Jekyll Docs Template -> IoT4 - 20070 -> Labs","body":"[Lab 1 - HTTP](./lab1)\n[Lab 2 - CoAP](./lab2)\n","preview":"<p><a href=\"./lab1\">Lab 1 - HTTP</a></p>\n"},{"path":"/lab1/#lab-1---http","title":"Lab 1 - HTTP -> Lab 1 - HTTP","body":"This is the HTTP lab. In this lab you will learn to understand the basics of HTTP, the Hypertext Transport Protocol, at a high level for the purposes of debugging IoT devices during development.\n","preview":"<p>This is the HTTP lab. In this lab you will learn to understand the basics of HTTP, the Hypertext Transport Protocol, at a high level for the purposes of debugging IoT devices during development.</p>\n"},{"path":"/lab1/#a-basic-request","title":"Lab 1 - HTTP -> Lab 1 - HTTP -> Part 1 - Understanding the basics of HTTP -> A Basic Request","body":"Copy and Paste the Following into the request box on [https://play-dev.exosite.io/http](https://play-dev.exosite.io/http):\nGET /timestamp HTTP/1.1\nHost: m2.exosite.com\n\n​\nNote: There are two blank lines after the text in the above example are important, make sure they are included after you paste into the `http terminal` page.\nPress the \\[Send\\] button.\nWhat happened? Do you think it worked?\nChange the word `GET` to `POST` and press \\[Send\\] again.\nYou'll see that the response changed. Compare the two different responses, one indicates an error and one indicates a success. Can you tell which is which?\nLook at the first line in the response, this is the status line, the number after `HTTP/1.1` is the status code (either an error code or some form of success code), which is then followed by the reason phrase. You'll see that the success response has a status code of \"200\" and a reason phrase of \"OK\". These two tell you the same information in *most* cases, but both are still required.\n","preview":"<p>Copy and Paste the Following into the request box on <a href=\"https://play-dev.exosite.io/http\">https://play-dev.exosite.io/http</a>:</p>\n"},{"path":"/lab1/#understanding-headers","title":"Lab 1 - HTTP -> Lab 1 - HTTP -> Part 1 - Understanding the basics of HTTP -> Understanding Headers","body":"Send the original request again, copy and paste the following into [https://play-dev.exosite.io/http](https://play-dev.exosite.io/http) :\nGET /timestamp HTTP/1.1\nHost: m2.exosite.com\n\n​\nPress the \\[Send\\] button.\nCompare the response of that request to the response of the following request:\nGET /timestamp HTTP/1.1\nHost: m2.exosite.com\nNot-A-Real-Header: kill-all-humans\n\n​\nDo you notice a difference?\nThere should be no difference (other than the timestamp itself and the date shown in line 2). The difference between the first and second requests was the addition of a new header, the \"Not-A-Real-Header\" header. There was no change in how the server responded because the server doesn't know of any header called \"Not-A-Real-Header\" so it is allowed to ignore it.\n","preview":"<p>Send the original request again, copy and paste the following into <a href=\"https://play-dev.exosite.io/http\">https://play-dev.exosite.io/http</a> :</p>\n"},{"path":"/lab1/#understanding-methods","title":"Lab 1 - HTTP -> Lab 1 - HTTP -> Part 1 - Understanding the basics of HTTP -> Understanding Methods","body":"Send the original request again, copy and paste the Following into [https://play-dev.exosite.io/http](https://play-dev.exosite.io/http) :\nGET /timestamp HTTP/1.1\nHost: m2.exosite.com\n\n​\nPress the \\[Send\\] button.\nCompare the response of that request to the response of the following request:\nPOST /timestamp HTTP/1.1\nHost: m2.exosite.com\n\n​\nDo you notice a difference?\nThe second request causes an error to be returned. In this case it's a `406 Method Not Allowed` because we changed the method from `GET` to `POST` and the timestamp url does not support having data `POST`ed to it. The method, sometimes also called the \"verb\", states what kind of request is being sent. The most common are `GET` and `POST`, but there's also `PUT`, `DELETE`, `OPTIONS`, `HEAD`, and more. Some of these will be further explained later in the lab.\n","preview":"<p>Send the original request again, copy and paste the Following into <a href=\"https://play-dev.exosite.io/http\">https://play-dev.exosite.io/http</a> :</p>\n"},{"path":"/lab1/#understanding-message-bodies","title":"Lab 1 - HTTP -> Lab 1 - HTTP -> Part 1 - Understanding the basics of HTTP -> Understanding Message Bodies","body":"Send the original request again, copy and paste the Following into [https://play-dev.exosite.io/http](https://play-dev.exosite.io/http) :\nGET /timestamp HTTP/1.1\nHost: m2.exosite.com\n\n​\nPress the \\[Send\\] button.\nCompare that **request** to the following request (the response is not interesting in this case):\nPOST /api:v1/rpc/process HTTP/1.1\nHost: m2.exosite.com\nContent-Length: 2\n\n{}\nWhat differences do you see?\nUntil now you've had to make sure that all your requests end with two blank lines, however this request ends with no blank lines. Ending with two blank lines is a special case of an HTTP message where the message contains no body, the two blank lines actually indicate the division between the end of the headers and the beginning of the body. Because HTTP runs over TCP, a stream protocol, it's important to know where one request ends and another begin. This is the purpose of the `Content-Length` header, it tells the receiver of the message how many octets (8-bit bytes) of body it should expect to receive.\n","preview":"<p>Send the original request again, copy and paste the Following into <a href=\"https://play-dev.exosite.io/http\">https://play-dev.exosite.io/http</a> :</p>\n"},{"path":"/lab1/#an-aside","title":"Lab 1 - HTTP -> Lab 1 - HTTP -> An Aside","body":"You don't need to fully understand what is happening in this section it's only used to generate a token that you will use later in this lab.\nPaste the following into the `script` box on [https://play-dev.exosite.io/script](https://play-dev.exosite.io/script).\nlocal exosite = require('https://lualib.webscript.io/exosite-lua-js.lua')\nlocal json = require(\"https://lualib.webscript.io/dkjson.lua\")\n\n-- create client through CIK Fountain\nlocal status, cik = exosite.get_temporary_cik()\nprint(\"USE THIS CIK: \" .. cik)\nprint(status, cik)\n\n-- create dataport\nlocal exo = exosite.rpc:new{cik = cik}\nlocal status, response = exo:create{\n  \"dataport\",\n  {\n    format = \"float\",\n    name = \"Temperature\",\n    retention = {\n      count = \"infinity\",\n      duration = \"infinity\"\n    }\n  }\n}\nprint(status, json.encode(response))\nlocal rid = response.result\n\n-- map alias to dataport\nlocal status, response = exo:map{\"alias\", rid, \"temp\"}\nprint(status, json.encode(response))\n\n-- write a value to dataport\nlocal status, response = exo:write{ {alias=\"temp\"}, 23.3}\nprint(status, json.encode(response))\n\n-- read value that was just written, for debugging purposes\nlocal status, response = exo:read{ {alias=\"temp\"}, {}}\nprint(status, json.encode(response))\n\n-- get info for client, for debugging purposes\nlocal status, response = exo:info{ {alias=\"\"}, {}}\nprint(status, json.encode(response))\nPress the \\[Run\\] button.\nNote: This will lock-up your browser tab for a few seconds while it does it's work.\nFind the CIK at the beginning of the log, it will be printed after \"USE THIS CIK:\". Copy it and **save this key** in a document on your computer, this is an auth token to be used with the Exosite platform which you will be using at various times later in this lab.\nIf you're curious, this is a lua script that runs within your browser, calling the Exosite [RPC API](http://docs.exosite.com/rpc) through a lua library included in the first line. It first creates a new client using the \"CIK Fountain\", which is a tool to create a client that will get automatically deleted in 30 minutes, and then creates some resources within that client that you will interact with later in this lab.\n","preview":"<p>You don&#39;t need to fully understand what is happening in this section it&#39;s only used to generate a token that you will use later in this lab.</p>\n"},{"path":"/lab1/#rest","title":"Lab 1 - HTTP -> Lab 1 - HTTP -> Request Patterns with HTTP -> REST","body":"REST, Representational State Transfer, is the most common form of communication pattern that is being built on top of HTTP currently. The following performs a rest-like request to the Exosite platform.\nCopy and Paste the Following into the request box on [https://play-dev.exosite.io/http](https://play-dev.exosite.io/http):\nGET /onep:v1/stack/alias?temp HTTP/1.1\nHost: m2.exosite.com\nX-Exosite-CIK: <CIK>\nAccept: application/x-www-form-urlencoded; charset=utf-8\n\n​\nNote:  Again, there are two blank lines after the text in the above example are important, make sure they are included after you paste into the `http terminal` page. Also, you'll need to replace the text `<CIK>` with the CIK (auth token) you generate in the previous section.\nPress the \\[Send\\] button.\nYou should have received a response that indicated that the 'temp' dataport had a value of '23.3'.\nTAKE IT FURTHER: The request you just made was a 'read' request the the Exosite device API, you can find the documentation for that call here, [http://docs.exosite.com/http/#read](http://docs.exosite.com/http/#read). Now, try and take what you've learned to make a write request, see the documentation for that call here, [http://docs.exosite.com/http/#write](http://docs.exosite.com/http/#write)\n","preview":"<p>REST, Representational State Transfer, is the most common form of communication pattern that is being built on top of HTTP currently. The following performs a rest-like request to the Exosite platform.</p>\n"},{"path":"/lab1/#rpc","title":"Lab 1 - HTTP -> Lab 1 - HTTP -> Request Patterns with HTTP -> RPC","body":"RPC, or Remote Procedure Call, is another communication pattern that can be built on top of HTTP. The following \nCopy and Paste the Following into the request box on [https://play-dev.exosite.io/http](https://play-dev.exosite.io/http):\nPOST /api:v1/rpc/process HTTP/1.1\nHost: m2.exosite.com\nContent-Length: 2\n\n{}\nPress the \\[Send\\] button.\nCompare the response of that request to the response of the following request:\nPOST /api:v1/rpc/process HTTP/1.1\nHost: m2.exosite.com\nContent-Length: 128\n\n{\n   \"auth\": \"<CIK>\",\n   \"calls\": [{\n       \"method\": \"not-a-real-method\",\n       \"arguments\": {}\n       \"id\": 56\n   }]\n}\nYou'll see that even though we tried to use a method that does not exist, `not-a-real-method`, we got an HTTP response code of 200 indicating success. This is because RPC does not use the HTTP status code to indicate the success or failure of the calls themselvce, but only if indicate if the server was able to process the format of the request. Errors within each call are returned via the 'status' and 'error' members of the call response.\nRPC has the benefit of being able to carry more than one 'call' in a single request. For example we can fetch the full info about a dataport in the same call the we read from it:\nPOST /api:v1/rpc/process HTTP/1.1\nHost: m2.exosite.com\nContent-Length: 2\n\n{\n  \"auth\": \"<CIK>\",\n  \"calls\": [{\n      \"method\": \"read\",\n      \"arguments\": {\n          {\"alias\": \"temp\"},\n          {}\n      },\n      \"id\": 56\n  },{\n      \"method\": \"info\",\n      \"arguments\": {\n          {\"alias\": \"temp\"},\n          {}\n      },\n      \"id\": \"something-else\"\n  }]\n\n}\n","preview":"<p>RPC, or Remote Procedure Call, is another communication pattern that can be built on top of HTTP. The following </p>\n"},{"path":"/lab2/#lab-2---coap","title":"Lab 2 - CoAP -> Lab 2 - CoAP","body":"This is the CoAP lab. In this lab you will learn to understand the CoAP protocol at a high level for the purposes of debugging IoT devices during development. Most of this lab should be familiar to you; the majority of it parallels Lab 1 on HTTP.\n","preview":"<p>This is the CoAP lab. In this lab you will learn to understand the CoAP protocol at a high level for the purposes of debugging IoT devices during development. Most of this lab should be familiar to you; the majority of it parallels Lab 1 on HTTP.</p>\n"},{"path":"/lab2/#part-1---understanding-the-basics-of-coap","title":"Lab 2 - CoAP -> Lab 2 - CoAP -> Part 1 - Understanding the basics of CoAP","body":"Note: The format of messages used in this lab is **not** the actual format of a CoAP message. CoAP is a binary protocol that is not easily human readable. Instead this lab uses a format of my own creation that I'm using purely for its ease of understanding. It's simply a JSON object where each member is one of the components of a CoAP message encoded in an human readable manner.\n","preview":"<p>Note: The format of messages used in this lab is <strong>not</strong> the actual format of a CoAP message. CoAP is a binary protocol that is not easily human readable. Instead this lab uses a format of my own creation that I&#39;m using purely for its ease of understanding. It&#39;s simply a JSON object where each member is one of the components of a CoAP message encoded in an human readable manner.</p>\n"},{"path":"/lab2/#a-basic-request","title":"Lab 2 - CoAP -> Lab 2 - CoAP -> Part 1 - Understanding the basics of CoAP -> A Basic Request","body":"Copy and Paste the Following into the request box on [https://play-dev.exosite.io/coap](https://play-dev.exosite.io/coap):\n{\n    \"version\": 1,\n    \"type\": \"CON\",\n    \"code\": \"GET\",\n    \"mid\": 55,\n    \"token\": [45,203],\n    \"opts\": {\n        \"UriPath\": [\n            \"ts\"\n        ]\n    }\n}\nPress the \\[Send\\] button.\nWhat happened? Do you think it worked?\nCompare this to the HTTP requests you made in Lab 1, it may not look it at first glance, but this request was very similar to the initial request in Lab 1. In lab 1 you made a \"get\" request to \"/timestamp\", in this lab you made a \"get\" request to \"/ts\".\nChange the word `GET` to `POST` and press \\[Send\\] again.\nYou'll see that the response changed. Compare the two different responses, one indicates an error and one indicates a success.\nLook at the `code` member in the JSON object, see that it changed from \"Content\" to \"MethodNotAllowed\", this should seem very similar to you after the the HTTP lab. In the HTTP lab the response reason was \"OK\", in CoAP \"Content\" has the same meaning (in addition to combining a few other HTTP reasons). When we changed to a POST we, again, got a response saying \"Method Not Allowed\". CoAP was designed to be very similar to HTTP so that developers already familiar with HTTP would be able to understand CoAP very quickly.\n","preview":"<p>Copy and Paste the Following into the request box on <a href=\"https://play-dev.exosite.io/coap\">https://play-dev.exosite.io/coap</a>:</p>\n"},{"path":"/lab2/#understanding-options","title":"Lab 2 - CoAP -> Lab 2 - CoAP -> Part 1 - Understanding the basics of CoAP -> Understanding Options","body":"Options in CoAP are very similar to headers in HTTP, let's explore them.\nSend the original request again, copy and paste the following into [https://play-dev.exosite.io/coap](https://play-dev.exosite.io/coap):\n{\n    \"version\": 1,\n    \"type\": \"CON\",\n    \"code\": \"GET\",\n    \"mid\": 55,\n    \"token\": [45,203],\n    \"opts\": {\n        \"UriPath\": [\n            \"ts\"\n        ]\n    }\n}\nThe one option that we are sending is a URI-Path option, in this case we're sending a URI with a single path component, that is to say the URI path is \"/ts\".\nPress the \\[Send\\] button.\nCompare the response of that request to the response of the following request:\n{\n    \"version\": 1,\n    \"type\": \"CON\",\n    \"code\": \"GET\",\n    \"mid\": 55,\n    \"token\": [45,203],\n    \"opts\": {\n        \"UriPath\": [\n            \"ts\"\n        ],\n        \"Accept\": 42\n    }\n}\nDo you notice a difference in the response?\nThis request adds an `Accept` option which specifies the format of the response that the requester would like to receive. There's no default value for Accept so the server is free to use any default format it wants. In the case of the second request we're setting a value of 42 which [is defined as](https://www.iana.org/assignments/core-parameters/core-parameters.xhtml#content-formats) \"application/octet-stream\", which just means \"arbitrary binary data\", and which we are using as a method to send a 32-bit timestamp in a raw format.\n","preview":"<p>Options in CoAP are very similar to headers in HTTP, let&#39;s explore them.</p>\n"},{"path":"/lab2/#understanding-codes","title":"Lab 2 - CoAP -> Lab 2 - CoAP -> Part 1 - Understanding the basics of CoAP -> Understanding Codes","body":"Again, much like a request method, coap uses a 'code' to define what the message type is.\nSend the original request again, copy and paste the following into [https://play-dev.exosite.io/coap](https://play-dev.exosite.io/coap):\n{\n    \"version\": 1,\n    \"type\": \"CON\",\n    \"code\": \"GET\",\n    \"mid\": 55,\n    \"token\": [45,203],\n    \"opts\": {\n        \"UriPath\": [\n            \"ts\"\n        ]\n    }\n}\nSee that in this request we have a 'code' of \"GET\" which indicates that this is the same type of request that would be used for an HTTP request with a method of \"GET\".\nPress the \\[Send\\] button.\nCompare that **request** to the following request (the response is not as important in this case):\n   {\n       \"version\": 1,\n       \"type\": \"CON\",\n       \"code\": \"POST\",\n       \"mid\": 56,\n       \"token\": [45,37],\n       \"opts\": {\n           \"UriPath\": [\n               \"rpc\"\n           ]\n       },\n       \"payload\": \"{}\"\n   }\nAgain, just like in HTTP we change from a \"GET\" to a \"POST\" and add a payload (\"body\" in HTTP terms.)\nYou should get an error response to that request, that is expected. We'll use POST requests that actually get a success response more in the RPC section.\n","preview":"<p>Again, much like a request method, coap uses a &#39;code&#39; to define what the message type is.</p>\n"},{"path":"/lab2/#an-aside","title":"Lab 2 - CoAP -> Lab 2 - CoAP -> An Aside","body":"You don't need to understand this part it's only used to generate a token that will be used later in this lab.\nYou may have already done this in Lab 1, but the keys that this script generates are automatically deleted periodically so your old key may no longer work.\nPaste the following into the `script` box on [https://play-dev.exosite.io/script](https://play-dev.exosite.io/script).\nlocal exosite = require('https://lualib.webscript.io/exosite-lua-js.lua')\nlocal json = require(\"https://lualib.webscript.io/dkjson.lua\")\n\n-- create client through CIK Fountain\nlocal status, cik = exosite.get_temporary_cik()\nprint(\"USE THIS CIK: \" .. cik)\nprint(status, cik)\n\n-- create dataport\nlocal exo = exosite.rpc:new{cik = cik}\nlocal status, response = exo:create{\n  \"dataport\",\n  {\n    format = \"float\",\n    name = \"Temperature\",\n    retention = {\n      count = \"infinity\",\n      duration = \"infinity\"\n    }\n  }\n}\nprint(status, json.encode(response))\nlocal rid = response.result\n\n-- map alias to dataport\nlocal status, response = exo:map{\"alias\", rid, \"temp\"}\nprint(status, json.encode(response))\n\n-- write a value to dataport\nlocal status, response = exo:write{ {alias=\"temp\"}, 23.3}\nprint(status, json.encode(response))\n\n-- read value that was just written, for debugging purposes\nlocal status, response = exo:read{ {alias=\"temp\"}, {}}\nprint(status, json.encode(response))\n\n-- get info for client, for debugging purposes\nlocal status, response = exo:info{ {alias=\"\"}, {}}\nprint(status, json.encode(response))\nPress the \\[Run\\] button.\nFind the CIK at the beginning of the log, it will be printed after \"USE THIS CIK:\". Copy it and **save this key** in a local document on your computer, this is an auth token to be used with the Exosite platform which you will be using at various times later in this lab.\nIf you're curious, this is a lua script that runs within your browser, calling the Exosite [RPC API](http://docs.exosite.com/rpc) through a lua library included in the first line. It first creates a new client using the \"CIK Fountain\", which is a tool to create a client that will get automatically deleted in 30 minutes, and then creates some resources within that client that you will interact with later in this lab.\n","preview":"<p>You don&#39;t need to understand this part it&#39;s only used to generate a token that will be used later in this lab.</p>\n"},{"path":"/lab2/#rest","title":"Lab 2 - CoAP -> Lab 2 - CoAP -> Request Patterns with HTTP -> Rest","body":"REST, or Representational State Transfer, is one of the simplest structured patterns that you can use on top of CoAP. This example shows making a REST-like request to Exosite's device API.\nCopy and Paste the Following into the request box on [https://play-dev.exosite.io/coap](https://play-dev.exosite.io/coap):\n{\n  \"version\": 1,\n  \"type\": \"CON\",\n  \"code\": \"GET\",\n  \"mid\": 9,\n  \"token\": [76,2203],\n  \"opts\": {\n    \"UriPath\": [\n      \"1a\",\n      \"temp\"\n    ],\n    \"UriQuery\": [\n      \"<CIK>\"\n    ],\n    \"Observe\":0\n  }\n}\nNote:  Again, there are two blank lines after the text in the above example are important, make sure they are included after you paste into the `http terminal` page. And make sure to replace `<CIK>` with the CIK you generated earlier.\nPress the \\[Send\\] button.\n","preview":"<p>REST, or Representational State Transfer, is one of the simplest structured patterns that you can use on top of CoAP. This example shows making a REST-like request to Exosite&#39;s device API.</p>\n"},{"path":"/lab2/#rpc","title":"Lab 2 - CoAP -> Lab 2 - CoAP -> Request Patterns with HTTP -> RPC","body":"RPC, or Remote Procedure Call, is another communication pattern that can be built on top of HTTP\nCopy and Paste the Following into the request box on [https://play-dev.exosite.io/coap](https://play-dev.exosite.io/coap):\n{\n    \"version\": 1,\n    \"type\": \"CON\",\n    \"code\": \"POST\",\n    \"mid\": 163,\n    \"token\": [9],\n    \"opts\": {\n        \"UriPath\": [\n            \"rpc\"\n        ],\n        \"ContentFormat\": 60,\n        \"Accept\": 60\n    },\n    \"payload\": {\n       \"auth\": {\n           \"cik\": \"<CIK>\"\n       },\n       \"calls\": [\n           {\n               \"procedure\": \"read\",\n               \"arguments\": [\n                   {\"alias\": \"temp\"},\n                   {}\n               ],\n               \"id\": 1\n           }\n       ]\n   }\n}\nNote:  There is a bit of extra magic going on here. This request has it's Content-Format set to '60' this is the Content-Format for [CBOR](http://cbor.io), a binary encoding format for JSON-like data structures. The CoAP Terminal will automatically encode an object-type payload into cbor when the Content-Format is set to application/cbor (60). It will also decode anything that looks like cbor into an object to be shown as JSON in the friendly format.\nPress the \\[Send\\] button.\n","preview":"<p>RPC, or Remote Procedure Call, is another communication pattern that can be built on top of HTTP</p>\n"}]