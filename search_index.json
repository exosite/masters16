[{"path":"/#iot4---20070","title":"Labs -- IoT4/20070 -> IoT4 - 20070","body":"This site hosts the labs for the IoT4 - 20070 class at Microchip MASTERS 2016. Use the links below see each lab.\n","preview":"<p>This site hosts the labs for the IoT4 - 20070 class at Microchip MASTERS 2016. Use the links below see each lab.</p>\n"},{"path":"/#labs","title":"Labs -- IoT4/20070 -> IoT4 - 20070 -> Labs","body":"[Lab 1](./lab1)\n[Lab 2](./lab2)\n<s>[Lab 3](./lab3)</s>\n","preview":"<p><a href=\"./lab1\">Lab 1</a></p>\n"},{"path":"/#optional-labs--guides","title":"Labs -- IoT4/20070 -> IoT4 - 20070 -> Optional Labs & Guides","body":"<s>[Lab Setup Guide](./setup)</s>\n<s>[Lab 4 - Murano](./lab4)</s>\n<s>[CoAP Lab](./coap)</s>\n<s>[HTTP Lab](./http)</s>\n","preview":"<p><s><a href=\"./setup\">Lab Setup Guide</a></s></p>\n"},{"path":"/coap_lab/#lab-2---coap","title":"Lab 2 - CoAP -> Lab 2 - CoAP","body":"This is the CoAP lab. In this lab you will learn to understand the CoAP protocol at a high level for the purposes of debugging IoT devices during development. Most of this lab should be familiar to you; the majority of it parallels Lab 1 on HTTP.\n","preview":"<p>This is the CoAP lab. In this lab you will learn to understand the CoAP protocol at a high level for the purposes of debugging IoT devices during development. Most of this lab should be familiar to you; the majority of it parallels Lab 1 on HTTP.</p>\n"},{"path":"/coap_lab/#part-1---understanding-the-basics-of-coap","title":"Lab 2 - CoAP -> Lab 2 - CoAP -> Part 1 - Understanding the basics of CoAP","body":"Note: The format of messages used in this lab is **not** the actual format of a CoAP message. CoAP is a binary protocol that is not easily human readable. Instead this lab uses a format of my own creation that I'm using purely for its ease of understanding. It's simply a JSON object where each member is one of the components of a CoAP message encoded in an human readable manner.\n","preview":"<p>Note: The format of messages used in this lab is <strong>not</strong> the actual format of a CoAP message. CoAP is a binary protocol that is not easily human readable. Instead this lab uses a format of my own creation that I&#39;m using purely for its ease of understanding. It&#39;s simply a JSON object where each member is one of the components of a CoAP message encoded in an human readable manner.</p>\n"},{"path":"/coap_lab/#a-basic-request","title":"Lab 2 - CoAP -> Lab 2 - CoAP -> Part 1 - Understanding the basics of CoAP -> A Basic Request","body":"Copy and Paste the Following into the request box on [https://play-dev.exosite.io/coap](https://play-dev.exosite.io/coap):\n{\n    \"version\": 1,\n    \"type\": \"CON\",\n    \"code\": \"GET\",\n    \"mid\": 55,\n    \"token\": [45,203],\n    \"opts\": {\n        \"UriPath\": [\n            \"ts\"\n        ]\n    }\n}\nPress the \\[Send\\] button.\nWhat happened? Do you think it worked?\nCompare this to the HTTP requests you made in Lab 1, it may not look it at first glance, but this request was very similar to the initial request in Lab 1. In lab 1 you made a \"get\" request to \"/timestamp\", in this lab you made a \"get\" request to \"/ts\".\nChange the word `GET` to `POST` and press \\[Send\\] again.\nYou'll see that the response changed. Compare the two different responses, one indicates an error and one indicates a success.\nLook at the `code` member in the JSON object, see that it changed from \"Content\" to \"MethodNotAllowed\", this should seem very similar to you after the the HTTP lab. In the HTTP lab the response reason was \"OK\", in CoAP \"Content\" has the same meaning (in addition to combining a few other HTTP reasons). When we changed to a POST we, again, got a response saying \"Method Not Allowed\". CoAP was designed to be very similar to HTTP so that developers already familiar with HTTP would be able to understand CoAP very quickly.\n","preview":"<p>Copy and Paste the Following into the request box on <a href=\"https://play-dev.exosite.io/coap\">https://play-dev.exosite.io/coap</a>:</p>\n"},{"path":"/coap_lab/#understanding-options","title":"Lab 2 - CoAP -> Lab 2 - CoAP -> Part 1 - Understanding the basics of CoAP -> Understanding Options","body":"Options in CoAP are very similar to headers in HTTP, let's explore them.\nSend the original request again, copy and paste the following into [https://play-dev.exosite.io/coap](https://play-dev.exosite.io/coap):\n{\n    \"version\": 1,\n    \"type\": \"CON\",\n    \"code\": \"GET\",\n    \"mid\": 55,\n    \"token\": [45,203],\n    \"opts\": {\n        \"UriPath\": [\n            \"ts\"\n        ]\n    }\n}\nThe one option that we are sending is a URI-Path option, in this case we're sending a URI with a single path component, that is to say the URI path is \"/ts\".\nPress the \\[Send\\] button.\nCompare the response of that request to the response of the following request:\n{\n    \"version\": 1,\n    \"type\": \"CON\",\n    \"code\": \"GET\",\n    \"mid\": 55,\n    \"token\": [45,203],\n    \"opts\": {\n        \"UriPath\": [\n            \"ts\"\n        ],\n        \"Accept\": 42\n    }\n}\nDo you notice a difference in the response?\nThis request adds an `Accept` option which specifies the format of the response that the requester would like to receive. There's no default value for Accept so the server is free to use any default format it wants. In the case of the second request we're setting a value of 42 which [is defined as](https://www.iana.org/assignments/core-parameters/core-parameters.xhtml#content-formats) \"application/octet-stream\", which just means \"arbitrary binary data\", and which we are using as a method to send a 32-bit timestamp in a raw format.\n","preview":"<p>Options in CoAP are very similar to headers in HTTP, let&#39;s explore them.</p>\n"},{"path":"/coap_lab/#understanding-codes","title":"Lab 2 - CoAP -> Lab 2 - CoAP -> Part 1 - Understanding the basics of CoAP -> Understanding Codes","body":"Again, much like a request method, coap uses a 'code' to define what the message type is.\nSend the original request again, copy and paste the following into [https://play-dev.exosite.io/coap](https://play-dev.exosite.io/coap):\n{\n    \"version\": 1,\n    \"type\": \"CON\",\n    \"code\": \"GET\",\n    \"mid\": 55,\n    \"token\": [45,203],\n    \"opts\": {\n        \"UriPath\": [\n            \"ts\"\n        ]\n    }\n}\nSee that in this request we have a 'code' of \"GET\" which indicates that this is the same type of request that would be used for an HTTP request with a method of \"GET\".\nPress the \\[Send\\] button.\nCompare that **request** to the following request (the response is not as important in this case):\n   {\n       \"version\": 1,\n       \"type\": \"CON\",\n       \"code\": \"POST\",\n       \"mid\": 56,\n       \"token\": [45,37],\n       \"opts\": {\n           \"UriPath\": [\n               \"rpc\"\n           ]\n       },\n       \"payload\": \"{}\"\n   }\nAgain, just like in HTTP we change from a \"GET\" to a \"POST\" and add a payload (\"body\" in HTTP terms.)\nYou should get an error response to that request, that is expected. We'll use POST requests that actually get a success response more in the RPC section.\n","preview":"<p>Again, much like a request method, coap uses a &#39;code&#39; to define what the message type is.</p>\n"},{"path":"/coap_lab/#an-aside","title":"Lab 2 - CoAP -> Lab 2 - CoAP -> An Aside","body":"You don't need to understand this part it's only used to generate a token that will be used later in this lab.\nYou may have already done this in Lab 1, but the keys that this script generates are automatically deleted periodically so your old key may no longer work.\nPaste the following into the `script` box on [https://play-dev.exosite.io/script](https://play-dev.exosite.io/script).\nlocal exosite = require('https://lualib.webscript.io/exosite-lua-js.lua')\nlocal json = require(\"https://lualib.webscript.io/dkjson.lua\")\n\n-- create client through CIK Fountain\nlocal status, cik = exosite.get_temporary_cik()\nprint(\"USE THIS CIK: \" .. cik)\nprint(status, cik)\n\n-- create dataport\nlocal exo = exosite.rpc:new{cik = cik}\nlocal status, response = exo:create{\n  \"dataport\",\n  {\n    format = \"float\",\n    name = \"Temperature\",\n    retention = {\n      count = \"infinity\",\n      duration = \"infinity\"\n    }\n  }\n}\nprint(status, json.encode(response))\nlocal rid = response.result\n\n-- map alias to dataport\nlocal status, response = exo:map{\"alias\", rid, \"temp\"}\nprint(status, json.encode(response))\n\n-- write a value to dataport\nlocal status, response = exo:write{ {alias=\"temp\"}, 23.3}\nprint(status, json.encode(response))\n\n-- read value that was just written, for debugging purposes\nlocal status, response = exo:read{ {alias=\"temp\"}, {}}\nprint(status, json.encode(response))\n\n-- get info for client, for debugging purposes\nlocal status, response = exo:info{ {alias=\"\"}, {}}\nprint(status, json.encode(response))\nPress the \\[Run\\] button.\nFind the CIK at the beginning of the log, it will be printed after \"USE THIS CIK:\". Copy it and **save this key** in a local document on your computer, this is an auth token to be used with the Exosite platform which you will be using at various times later in this lab.\nIf you're curious, this is a lua script that runs within your browser, calling the Exosite [RPC API](http://docs.exosite.com/rpc) through a lua library included in the first line. It first creates a new client using the \"CIK Fountain\", which is a tool to create a client that will get automatically deleted in 30 minutes, and then creates some resources within that client that you will interact with later in this lab.\n","preview":"<p>You don&#39;t need to understand this part it&#39;s only used to generate a token that will be used later in this lab.</p>\n"},{"path":"/coap_lab/#rest","title":"Lab 2 - CoAP -> Lab 2 - CoAP -> Request Patterns with HTTP -> Rest","body":"REST, or Representational State Transfer, is one of the simplest structured patterns that you can use on top of CoAP. This example shows making a REST-like request to Exosite's device API.\nCopy and Paste the Following into the request box on [https://play-dev.exosite.io/coap](https://play-dev.exosite.io/coap):\n{\n  \"version\": 1,\n  \"type\": \"CON\",\n  \"code\": \"GET\",\n  \"mid\": 9,\n  \"token\": [76,2203],\n  \"opts\": {\n    \"UriPath\": [\n      \"1a\",\n      \"temp\"\n    ],\n    \"UriQuery\": [\n      \"<CIK>\"\n    ],\n    \"Observe\":0\n  }\n}\nNote:  Again, there are two blank lines after the text in the above example are important, make sure they are included after you paste into the `http terminal` page. And make sure to replace `<CIK>` with the CIK you generated earlier.\nPress the \\[Send\\] button.\n","preview":"<p>REST, or Representational State Transfer, is one of the simplest structured patterns that you can use on top of CoAP. This example shows making a REST-like request to Exosite&#39;s device API.</p>\n"},{"path":"/coap_lab/#rpc","title":"Lab 2 - CoAP -> Lab 2 - CoAP -> Request Patterns with HTTP -> RPC","body":"RPC, or Remote Procedure Call, is another communication pattern that can be built on top of HTTP\nCopy and Paste the Following into the request box on [https://play-dev.exosite.io/coap](https://play-dev.exosite.io/coap):\n{\n    \"version\": 1,\n    \"type\": \"CON\",\n    \"code\": \"POST\",\n    \"mid\": 163,\n    \"token\": [9],\n    \"opts\": {\n        \"UriPath\": [\n            \"rpc\"\n        ],\n        \"ContentFormat\": 60,\n        \"Accept\": 60\n    },\n    \"payload\": {\n       \"auth\": {\n           \"cik\": \"<CIK>\"\n       },\n       \"calls\": [\n           {\n               \"procedure\": \"read\",\n               \"arguments\": [\n                   {\"alias\": \"temp\"},\n                   {}\n               ],\n               \"id\": 1\n           }\n       ]\n   }\n}\nNote:  There is a bit of extra magic going on here. This request has it's Content-Format set to '60' this is the Content-Format for [CBOR](http://cbor.io), a binary encoding format for JSON-like data structures. The CoAP Terminal will automatically encode an object-type payload into cbor when the Content-Format is set to application/cbor (60). It will also decode anything that looks like cbor into an object to be shown as JSON in the friendly format.\nPress the \\[Send\\] button.\n","preview":"<p>RPC, or Remote Procedure Call, is another communication pattern that can be built on top of HTTP</p>\n"},{"path":"/http_lab/#lab-1---http","title":"Lab 1 - HTTP -> Lab 1 - HTTP","body":"This is the HTTP lab. In this lab you will learn to understand the basics of HTTP, the Hypertext Transport Protocol, at a high level for the purposes of debugging IoT devices during development.\n","preview":"<p>This is the HTTP lab. In this lab you will learn to understand the basics of HTTP, the Hypertext Transport Protocol, at a high level for the purposes of debugging IoT devices during development.</p>\n"},{"path":"/http_lab/#a-basic-request","title":"Lab 1 - HTTP -> Lab 1 - HTTP -> Part 1 - Understanding the basics of HTTP -> A Basic Request","body":"Copy and Paste the Following into the request box on [https://play-dev.exosite.io/http](https://play-dev.exosite.io/http):\nGET /timestamp HTTP/1.1\nHost: m2.exosite.com\n\n​\nNote: There are two blank lines after the text in the above example are important, make sure they are included after you paste into the `http terminal` page.\nPress the \\[Send\\] button.\nWhat happened? Do you think it worked?\nChange the word `GET` to `POST` and press \\[Send\\] again.\nYou'll see that the response changed. Compare the two different responses, one indicates an error and one indicates a success. Can you tell which is which?\nLook at the first line in the response, this is the status line, the number after `HTTP/1.1` is the status code (either an error code or some form of success code), which is then followed by the reason phrase. You'll see that the success response has a status code of \"200\" and a reason phrase of \"OK\". These two tell you the same information in *most* cases, but both are still required.\n","preview":"<p>Copy and Paste the Following into the request box on <a href=\"https://play-dev.exosite.io/http\">https://play-dev.exosite.io/http</a>:</p>\n"},{"path":"/http_lab/#understanding-headers","title":"Lab 1 - HTTP -> Lab 1 - HTTP -> Part 1 - Understanding the basics of HTTP -> Understanding Headers","body":"Send the original request again, copy and paste the following into [https://play-dev.exosite.io/http](https://play-dev.exosite.io/http) :\nGET /timestamp HTTP/1.1\nHost: m2.exosite.com\n\n​\nPress the \\[Send\\] button.\nCompare the response of that request to the response of the following request:\nGET /timestamp HTTP/1.1\nHost: m2.exosite.com\nNot-A-Real-Header: kill-all-humans\n\n​\nDo you notice a difference?\nThere should be no difference (other than the timestamp itself and the date shown in line 2). The difference between the first and second requests was the addition of a new header, the \"Not-A-Real-Header\" header. There was no change in how the server responded because the server doesn't know of any header called \"Not-A-Real-Header\" so it is allowed to ignore it.\n","preview":"<p>Send the original request again, copy and paste the following into <a href=\"https://play-dev.exosite.io/http\">https://play-dev.exosite.io/http</a> :</p>\n"},{"path":"/http_lab/#understanding-methods","title":"Lab 1 - HTTP -> Lab 1 - HTTP -> Part 1 - Understanding the basics of HTTP -> Understanding Methods","body":"Send the original request again, copy and paste the Following into [https://play-dev.exosite.io/http](https://play-dev.exosite.io/http) :\nGET /timestamp HTTP/1.1\nHost: m2.exosite.com\n\n​\nPress the \\[Send\\] button.\nCompare the response of that request to the response of the following request:\nPOST /timestamp HTTP/1.1\nHost: m2.exosite.com\n\n​\nDo you notice a difference?\nThe second request causes an error to be returned. In this case it's a `406 Method Not Allowed` because we changed the method from `GET` to `POST` and the timestamp url does not support having data `POST`ed to it. The method, sometimes also called the \"verb\", states what kind of request is being sent. The most common are `GET` and `POST`, but there's also `PUT`, `DELETE`, `OPTIONS`, `HEAD`, and more. Some of these will be further explained later in the lab.\n","preview":"<p>Send the original request again, copy and paste the Following into <a href=\"https://play-dev.exosite.io/http\">https://play-dev.exosite.io/http</a> :</p>\n"},{"path":"/http_lab/#understanding-message-bodies","title":"Lab 1 - HTTP -> Lab 1 - HTTP -> Part 1 - Understanding the basics of HTTP -> Understanding Message Bodies","body":"Send the original request again, copy and paste the Following into [https://play-dev.exosite.io/http](https://play-dev.exosite.io/http) :\nGET /timestamp HTTP/1.1\nHost: m2.exosite.com\n\n​\nPress the \\[Send\\] button.\nCompare that **request** to the following request (the response is not interesting in this case):\nPOST /api:v1/rpc/process HTTP/1.1\nHost: m2.exosite.com\nContent-Length: 2\n\n{}\nWhat differences do you see?\nUntil now you've had to make sure that all your requests end with two blank lines, however this request ends with no blank lines. Ending with two blank lines is a special case of an HTTP message where the message contains no body, the two blank lines actually indicate the division between the end of the headers and the beginning of the body. Because HTTP runs over TCP, a stream protocol, it's important to know where one request ends and another begin. This is the purpose of the `Content-Length` header, it tells the receiver of the message how many octets (8-bit bytes) of body it should expect to receive.\n","preview":"<p>Send the original request again, copy and paste the Following into <a href=\"https://play-dev.exosite.io/http\">https://play-dev.exosite.io/http</a> :</p>\n"},{"path":"/http_lab/#an-aside","title":"Lab 1 - HTTP -> Lab 1 - HTTP -> An Aside","body":"You don't need to fully understand what is happening in this section it's only used to generate a token that you will use later in this lab.\nPaste the following into the `script` box on [https://play-dev.exosite.io/script](https://play-dev.exosite.io/script).\nlocal exosite = require('https://lualib.webscript.io/exosite-lua-js.lua')\nlocal json = require(\"https://lualib.webscript.io/dkjson.lua\")\n\n-- create client through CIK Fountain\nlocal status, cik = exosite.get_temporary_cik()\nprint(\"USE THIS CIK: \" .. cik)\nprint(status, cik)\n\n-- create dataport\nlocal exo = exosite.rpc:new{cik = cik}\nlocal status, response = exo:create{\n  \"dataport\",\n  {\n    format = \"float\",\n    name = \"Temperature\",\n    retention = {\n      count = \"infinity\",\n      duration = \"infinity\"\n    }\n  }\n}\nprint(status, json.encode(response))\nlocal rid = response.result\n\n-- map alias to dataport\nlocal status, response = exo:map{\"alias\", rid, \"temp\"}\nprint(status, json.encode(response))\n\n-- write a value to dataport\nlocal status, response = exo:write{ {alias=\"temp\"}, 23.3}\nprint(status, json.encode(response))\n\n-- read value that was just written, for debugging purposes\nlocal status, response = exo:read{ {alias=\"temp\"}, {}}\nprint(status, json.encode(response))\n\n-- get info for client, for debugging purposes\nlocal status, response = exo:info{ {alias=\"\"}, {}}\nprint(status, json.encode(response))\nPress the \\[Run\\] button.\nNote: This will lock-up your browser tab for a few seconds while it does it's work.\nFind the CIK at the beginning of the log, it will be printed after \"USE THIS CIK:\". Copy it and **save this key** in a document on your computer, this is an auth token to be used with the Exosite platform which you will be using at various times later in this lab.\nIf you're curious, this is a lua script that runs within your browser, calling the Exosite [RPC API](http://docs.exosite.com/rpc) through a lua library included in the first line. It first creates a new client using the \"CIK Fountain\", which is a tool to create a client that will get automatically deleted in 30 minutes, and then creates some resources within that client that you will interact with later in this lab.\n","preview":"<p>You don&#39;t need to fully understand what is happening in this section it&#39;s only used to generate a token that you will use later in this lab.</p>\n"},{"path":"/http_lab/#rest","title":"Lab 1 - HTTP -> Lab 1 - HTTP -> Request Patterns with HTTP -> REST","body":"REST, Representational State Transfer, is the most common form of communication pattern that is being built on top of HTTP currently. The following performs a rest-like request to the Exosite platform.\nCopy and Paste the Following into the request box on [https://play-dev.exosite.io/http](https://play-dev.exosite.io/http):\nGET /onep:v1/stack/alias?temp HTTP/1.1\nHost: m2.exosite.com\nX-Exosite-CIK: <CIK>\nAccept: application/x-www-form-urlencoded; charset=utf-8\n\n​\nNote:  Again, there are two blank lines after the text in the above example are important, make sure they are included after you paste into the `http terminal` page. Also, you'll need to replace the text `<CIK>` with the CIK (auth token) you generate in the previous section.\nPress the \\[Send\\] button.\nYou should have received a response that indicated that the 'temp' dataport had a value of '23.3'.\nTAKE IT FURTHER: The request you just made was a 'read' request the the Exosite device API, you can find the documentation for that call here, [http://docs.exosite.com/http/#read](http://docs.exosite.com/http/#read). Now, try and take what you've learned to make a write request, see the documentation for that call here, [http://docs.exosite.com/http/#write](http://docs.exosite.com/http/#write)\n","preview":"<p>REST, Representational State Transfer, is the most common form of communication pattern that is being built on top of HTTP currently. The following performs a rest-like request to the Exosite platform.</p>\n"},{"path":"/http_lab/#rpc","title":"Lab 1 - HTTP -> Lab 1 - HTTP -> Request Patterns with HTTP -> RPC","body":"RPC, or Remote Procedure Call, is another communication pattern that can be built on top of HTTP. The following \nCopy and Paste the Following into the request box on [https://play-dev.exosite.io/http](https://play-dev.exosite.io/http):\nPOST /api:v1/rpc/process HTTP/1.1\nHost: m2.exosite.com\nContent-Length: 2\n\n{}\nPress the \\[Send\\] button.\nCompare the response of that request to the response of the following request:\nPOST /api:v1/rpc/process HTTP/1.1\nHost: m2.exosite.com\nContent-Length: 128\n\n{\n   \"auth\": \"<CIK>\",\n   \"calls\": [{\n       \"method\": \"not-a-real-method\",\n       \"arguments\": {}\n       \"id\": 56\n   }]\n}\nYou'll see that even though we tried to use a method that does not exist, `not-a-real-method`, we got an HTTP response code of 200 indicating success. This is because RPC does not use the HTTP status code to indicate the success or failure of the calls themselvce, but only if indicate if the server was able to process the format of the request. Errors within each call are returned via the 'status' and 'error' members of the call response.\nRPC has the benefit of being able to carry more than one 'call' in a single request. For example we can fetch the full info about a dataport in the same call the we read from it:\nPOST /api:v1/rpc/process HTTP/1.1\nHost: m2.exosite.com\nContent-Length: 2\n\n{\n  \"auth\": \"<CIK>\",\n  \"calls\": [{\n      \"method\": \"read\",\n      \"arguments\": {\n          {\"alias\": \"temp\"},\n          {}\n      },\n      \"id\": 56\n  },{\n      \"method\": \"info\",\n      \"arguments\": {\n          {\"alias\": \"temp\"},\n          {}\n      },\n      \"id\": \"something-else\"\n  }]\n\n}\n","preview":"<p>RPC, or Remote Procedure Call, is another communication pattern that can be built on top of HTTP. The following </p>\n"},{"path":"/lab1/#lab-1---getting-started-with-the-exositeready-sdk","title":"Lab 1 - Getting Started with the ExositeReady SDK -> Lab 1 - Getting Started with the ExositeReady SDK","body":"The ExositeReady SDK is a software framework provided by Exosite to ease development of production-quality embedded device firmware for IoT products. It's open source software, provided under the Apache-2.0 license, that means that you're free to do whatever you'd like with it as long as you share any changes to the SDK itself while being able to keep the rest of your application's code private if that's what you'd like.\nIn this lab you'll go through getting the PIC32MZ Embedded Connectivity Starter Kit flashed with the demo firmware provided alongside the ER SKD. You'll learn the basics of what is required to get IoT devices connected to the Exosite platform and see real-time data from your devices streaming to your web browser.\n","preview":"<p>The ExositeReady SDK is a software framework provided by Exosite to ease development of production-quality embedded device firmware for IoT products. It&#39;s open source software, provided under the Apache-2.0 license, that means that you&#39;re free to do whatever you&#39;d like with it as long as you share any changes to the SDK itself while being able to keep the rest of your application&#39;s code private if that&#39;s what you&#39;d like.</p>\n"},{"path":"/lab1/#requirements","title":"Lab 1 - Getting Started with the ExositeReady SDK -> Lab 1 - Getting Started with the ExositeReady SDK -> Requirements","body":"PIC32MZ Embedded Connectivity Starter Kit\nAn Internet Connection\nA Computer with MPLAB IDE, including:\nMPLABX IDE v 3.30\nHarmony v1.08\nXC32 v1.40b\nThe ExositeReady SDK, plus\nThe PIC32MZECSK port & example application\nIf you don't have any of the above software installed, see Tool Setup section before proceeding with this Lab. MASTERS attendees that have access to the in-class lab computers will have this setup already.\n","preview":"<p>PIC32MZ Embedded Connectivity Starter Kit</p>\n"},{"path":"/lab1/#lets-go","title":"Lab 1 - Getting Started with the ExositeReady SDK -> Let's Go","body":"First you'll want to open MPLAB X.\n![MPLABX IDE Screenshot](/images/mplabx.png)\nAnd open the `exositeready_pic32mz` project, which can be found in the \"C:\\microchip\\harmony\\v1_08\\apps\\exositeready_pic32mz\\firmware\" folder.\n![Open Example Project](/images/open_example_project.png)\nYou can now explore the source of this project if you'd like.\n![Example Project Fresh](/images/example_project_fresh.png)\n","preview":"<p>First you&#39;ll want to open MPLAB X.</p>\n"},{"path":"/lab1/#running-the-example","title":"Lab 1 - Getting Started with the ExositeReady SDK -> Let's Go -> Running the Example","body":"Before we dig into what the code is doing, let's build, flash, and run the provided example.\nConnect the Starter Kit board to you computer using both mini USB connectors; one is for the onboard debugger and the other is for access to the serial terminal.\nIf you have more than one project open in MPLAB, make sure that the `exositeready_pic32mz` project is set as the main project, it's name should appear in the window's title bar, you can do this simply clicking on the project in the 'Projects' tab in the left-side bar.\nIf you have more than one project open, make sure that the `exositeready_pic32mz` project is set as the currently active project. The click the \"Make and Program Device Main Project\" button.\n![Make and Program Device Main Project Button](images/make_and_program_device_main_project_button.png)\nYou may be prompted to select a different device, this will happen if the starter kit you're using isn't the last one used with this project. MPLAB should offer to switch to the kit that is currently connected to your computer; just click \"OK\". If you're shown a list of tools, there should only be one valid option. Choose the item listed under \"Starter Kits (PKOB)\".\n![Tool List](images/tool_list.png)\nIt will take several minutes to compile and flash the board.\nOnce this is complete, the board will boot the demo application, connect to Exosite's servers, and begin reading & writing data. Once this happens you should see the three LEDs along the 40-pin header turn on.\nTo follow the progress of the application booting and connecting you can use a serial terminal application to view the application's debug log. Open the serial terminal application on the computer and connect to the virtual serial port provided by the device, it should be the only one available on your computer.\n<!-- NTS: Expand the above section after figuring out what application they will have on these machines. -->\n\n","preview":"<p>Before we dig into what the code is doing, let&#39;s build, flash, and run the provided example.</p>\n"},{"path":"/lab2/#lab-2---exploring-the-source","title":"Lab 2 - Exploring the Source -> Lab 2 - Exploring the Source","body":"You've now had some experience using the ExositeReady SDK on the Embedded Connectivity Starter Kit and have gotten it to connect to the Exosite platform. Next, in this lab, you'll explore the code more and make some subtle tweaks to how the example reports data to the platform. This is intended to increase your familiarity with where the key pieces of functionality are handled in the application.\n","preview":"<p>You&#39;ve now had some experience using the ExositeReady SDK on the Embedded Connectivity Starter Kit and have gotten it to connect to the Exosite platform. Next, in this lab, you&#39;ll explore the code more and make some subtle tweaks to how the example reports data to the platform. This is intended to increase your familiarity with where the key pieces of functionality are handled in the application.</p>\n"},{"path":"/lab2/#requirements","title":"Lab 2 - Exploring the Source -> Lab 2 - Exploring the Source -> Requirements","body":"PIC32MZ Embedded Connectivity Starter Kit\nAn Internet Connection\nA Computer with MPLAB IDE, including:\nMPLABX IDE v 3.30\nHarmony v1.08\nXC32 v1.40b\nThe ExositeReady SDK, plus\nThe PIC32MZECSK port & example application\nThe requirements here are the same as the first lab. If you have not completed that lab yet, it's **highly** recommend you do so before starting this lab.\n","preview":"<p>PIC32MZ Embedded Connectivity Starter Kit</p>\n"},{"path":"/lab2/#exploring-the-code","title":"Lab 2 - Exploring the Source -> Exploring the Code","body":"We'll start of in the source for the main application code which you can find in `Source File -> app -> app.c`. In this file you'll find the main `APP_TASKS` function that should be familiar to you if you've ever written firmware using Microchip's Harmony libraries before.\nIf you're not familiar with this application structure, you'll see that the application is structured as a state machine where the APP_TASKS function returns when it is done with it's current task, keeping track of the application's state in the appData global variable structure. The main body of the function takes the form of a single switch statement with each case being an individual state of the state machine.\nTry to follow the state through the application and understand the basic progression of the state machine.\nIn this application the app will spend most of it's time in the `APP_APPLICATION` state. This is where all the interaction with the Exosite platform is controlled.\nHere you can see that we're writing some data based on the state of the buttons; this state is being written to a dataport with the alias \"btn\", it's simply a numeric value that indicates which button is pressed.\nTake note that the numeric value of the button press is converted to ASCII text. All requests that are sent to the API this demo uses require the messages to be UTF-8 encoded (of which ASCII is a subset, if you didn't know) so this library requires you to format all your requests before handing them off. It's done this way to simplify the communication protocols, using only standard web protocols and formats.\nYou will also see some code for reading the state for displaying on the LEDs from the 'leds' dataport, this is again a numeric value that encoded the state of each LED. It uses a simplistic encoding, see if you can figure out what it is.\nThis way of encoding multiple independent inputs and outputs is done to reduce the resources required to communicate the data to the platform. You could split each LED and button into their own dataport, but that would require writing to multiple dataports and, more importantly, opening several connections to the platform to wait on changes to each dataport. This is largely a limitation of the API used by this library, Exosite has new device-side APIs that will get rid of this limitation.\n","preview":"<p>We&#39;ll start of in the source for the main application code which you can find in <code>Source File -&gt; app -&gt; app.c</code>. In this file you&#39;ll find the main <code>APP_TASKS</code> function that should be familiar to you if you&#39;ve ever written firmware using Microchip&#39;s Harmony libraries before.</p>\n"},{"path":"/lab2/#making-some-tweaks","title":"Lab 2 - Exploring the Source -> Making some Tweaks","body":"The 'Product' model that is being used for these demos has a few more dataports we didn't use in the first lab. We want to read the `party_leds` dataport and use that value to set the state of the LEDs. We'll also want to make the buttons change the value in the `party_on_off` dataport.\nThe `party_leds` dataport uses the same format as the `leds` dataport. The `party_on_off` dataport takes either a \"1\" or a \"0\".\nBefore continuing to read the lab, try to see if you can make the changes to use these dataports instead of the ones included in the original example. If you're having trouble the following section will walk you through the steps needed.\n","preview":"<p>The &#39;Product&#39; model that is being used for these demos has a few more dataports we didn&#39;t use in the first lab. We want to read the <code>party_leds</code> dataport and use that value to set the state of the LEDs. We&#39;ll also want to make the buttons change the value in the <code>party_on_off</code> dataport.</p>\n"},{"path":"/lab2/#the-walkthrough","title":"Lab 2 - Exploring the Source -> Making some Tweaks -> The Walkthrough","body":"tbc.\n","preview":"<p>tbc.</p>\n"},{"path":"/plan/#yaks","title":"plan -> Goal: Write Labs -> Yaks","body":"Make public UI for devices.\nWrite simple \"starting-point\" application using LEDs and buttons.\n","preview":"<p>Make public UI for devices.</p>\n"}]